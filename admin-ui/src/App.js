import React, { useEffect, useState, useRef, useCallback, useMemo } from 'react';
import { BrowserRouter as Router, Routes, Route, useNavigate } from 'react-router-dom';
import {
  Box, CircularProgress, AppBar, CssBaseline, Toolbar, Typography
} from '@mui/material';

// Importar componentes
import { Sidebar } from './components/Sidebar';
import OverviewPage from './pages/OverviewPage';
import SessionsPage from './pages/SessionsPage';
import PlayerPage from './pages/PlayerPage';

// CSS para anima√ß√µes
const styles = `
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
  }
`;

// Inserir CSS no head se ainda n√£o existir
if (!document.querySelector('#clarity-styles')) {
  const styleSheet = document.createElement('style');
  styleSheet.id = 'clarity-styles';
  styleSheet.textContent = styles;
  document.head.appendChild(styleSheet);
}

const drawerWidth = 280;

// Componente principal da aplica√ß√£o com router
function AppContent() {
  const navigate = useNavigate();

  // Estados principais
  const [groups, setGroups] = useState({});
  const [loading, setLoading] = useState(true);
  const [sessionStats, setSessionStats] = useState(new Map());
  const [disconnectedSessions, setDisconnectedSessions] = useState(new Set());

  // Estados do player
  const [currentImageIndex, setCurrentImageIndex] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [playbackSpeed, setPlaybackSpeed] = useState(42); // ms between frames (24 FPS)

  // Estados WebSocket
  const [wsServerConnected, setWsServerConnected] = useState(false);

  const videoIntervalRef = useRef(null);

  // Configura√ß√µes com vari√°veis de ambiente corretas
  const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:3001';
  const heatmapWsUrl = process.env.REACT_APP_HEATMAP_WS_URL || 'ws://localhost:3002';

  // Throttle para evitar m√∫ltiplas chamadas
  const lastFetchTime = useRef(0);
  const FETCH_THROTTLE = 2000; // 2 segundos entre chamadas

  // Fun√ß√£o para buscar imagens com throttling
  const fetchImages = useCallback(async () => {
    const now = Date.now();
    if (now - lastFetchTime.current < FETCH_THROTTLE) {
      console.log('‚è∏Ô∏è Fetch throttled - muito recente');
      return;
    }

    try {
      lastFetchTime.current = now;
      setLoading(true);

      console.log('üîÑ Buscando imagens do servidor...');
      const response = await fetch(`${apiUrl}/api/images`);
      const data = await response.json();

      // Ordenar por timestamp da √∫ltima imagem de cada sess√£o
      const sortedGroups = Object.entries(data).sort(([, a], [, b]) => {
        const lastA = a.length > 0 ? Math.max(...a.map(img => img.timestamp)) : 0;
        const lastB = b.length > 0 ? Math.max(...b.map(img => img.timestamp)) : 0;
        return lastB - lastA;
      });

      setGroups(Object.fromEntries(sortedGroups));

      // Atualizar estat√≠sticas das sess√µes
      const newStats = new Map();
      sortedGroups.forEach(([sessionId, images]) => {
        if (images.length > 0) {
          const timestamps = images.map(img => img.timestamp);
          const startTime = Math.min(...timestamps);
          const endTime = Math.max(...timestamps);

          newStats.set(sessionId, {
            totalImages: images.length,
            startTime: new Date(startTime),
            endTime: new Date(endTime),
            duration: Math.round((endTime - startTime) / 1000),
            sessionId: sessionId
          });
        } else {
          // Sess√£o ativa sem imagens
          newStats.set(sessionId, {
            totalImages: 0,
            startTime: new Date(),
            endTime: new Date(),
            duration: 0,
            sessionId: sessionId,
            isActive: true
          });
        }
      });

      setSessionStats(newStats);
      setLoading(false);
      console.log(`üìä Carregadas ${sortedGroups.length} sess√µes (${Array.from(newStats.values()).reduce((sum, stat) => sum + stat.totalImages, 0)} imagens)`);

    } catch (error) {
      console.error('Erro ao buscar imagens:', error);
      setLoading(false);
      setGroups({});
      setSessionStats(new Map());
    }
  }, [apiUrl]);

  // Fun√ß√£o para deletar sess√£o
  const deleteSession = useCallback(async (sessionId) => {
    if (!window.confirm(`Tem certeza que deseja deletar a sess√£o ${sessionId}?`)) {
      return;
    }

    try {
      console.log(`üóëÔ∏è Deletando sess√£o: ${sessionId}`);

      const response = await fetch(`${apiUrl}/api/session/${sessionId}`, {
        method: 'DELETE'
      });

      if (response.ok) {
        const result = await response.json();
        console.log(`‚úÖ Sess√£o deletada:`, result);

        // Atualizar lista de imagens ap√≥s dele√ß√£o
        setTimeout(() => fetchImages(), 1000);

        // Mostrar notifica√ß√£o de sucesso
        alert(`Sess√£o ${sessionId} deletada com sucesso!\nArquivos removidos: ${result.deletedFiles}`);
      } else {
        const error = await response.json();
        console.error('Erro ao deletar sess√£o:', error);
        alert(`Erro ao deletar sess√£o: ${error.message || 'Erro desconhecido'}`);
      }
    } catch (error) {
      console.error('Erro ao deletar sess√£o:', error);
      alert(`Erro ao deletar sess√£o: ${error.message}`);
    }
  }, [apiUrl, fetchImages]);

  // Handlers para o player
  const handlePlayPause = useCallback(() => {
    if (isPlaying) {
      clearInterval(videoIntervalRef.current);
      setIsPlaying(false);
    } else {
      setIsPlaying(true);
      videoIntervalRef.current = setInterval(() => {
        setCurrentImageIndex(prev => {
          // Se chegou no √∫ltimo frame, para a reprodu√ß√£o
          if (prev >= (groups ? Object.values(groups)[0]?.length - 1 : 0)) {
            clearInterval(videoIntervalRef.current);
            setIsPlaying(false);
            return prev; // Mant√©m no √∫ltimo frame
          }
          return prev + 1;
        });
      }, playbackSpeed);
    }
  }, [isPlaying, groups, playbackSpeed]);

  const handleStop = useCallback(() => {
    clearInterval(videoIntervalRef.current);
    setIsPlaying(false);
    setCurrentImageIndex(0);
  }, []);

  // Handlers para navega√ß√£o
  const handleSelectSession = useCallback((sessionId) => {
    navigate(`/player/${sessionId}`);
  }, [navigate]);

  const handleCreateVideo = useCallback((sessionId) => {
    navigate(`/player/${sessionId}`);
    setCurrentImageIndex(0);
  }, [navigate]);

  // Conectar ao WebSocket para receber atualiza√ß√µes em tempo real
  useEffect(() => {
    let isConnected = false;
    let reconnectTimeout = null;
    let ws = null;

    const connectToWebSocket = () => {
      if (ws) {
        ws.close();
      }

      try {
        console.log('üîå Conectando ao WebSocket do heatmap...');
        ws = new WebSocket(heatmapWsUrl);

        ws.onopen = () => {
          console.log('‚úÖ WebSocket do heatmap conectado');
          setWsServerConnected(true);
          isConnected = true;

          // Buscar imagens ap√≥s conex√£o
          fetchImages();
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log('ÔøΩÔøΩ Mensagem WebSocket do heatmap recebida:', data);

            switch (data.type) {
              case 'image_uploaded':
                console.log(`üñºÔ∏è Nova imagem enviada: ${data.filename} (sess√£o: ${data.sessionId})`);
                // Throttled fetch para evitar m√∫ltiplas chamadas
                setTimeout(() => fetchImages(), 1000);
                break;

              case 'upload_in_progress':
                console.log(`‚è≥ Upload em progresso (sess√£o: ${data.sessionId})`);
                // Opcional: mostrar indicador de upload
                break;

              case 'session_started':
                console.log(`üÜï Nova sess√£o heatmap iniciada: ${data.sessionId}`);
                // Esperar um pouco para sess√£o se estabelecer
                setTimeout(() => fetchImages(), 2000);
                break;

              case 'session_ended':
                console.log(`‚èπÔ∏è Sess√£o heatmap finalizada: ${data.sessionId}`);
                // Marcar sess√£o como desconectada
                setDisconnectedSessions(prev => new Set(prev).add(data.sessionId));
                setTimeout(() => fetchImages(), 1000);
                break;

              case 'connections_status':
                console.log(`üìä Status das conex√µes heatmap:`, data.connections);
                // Atualizar status das conex√µes ativas
                break;

              case 'upload_success':
                console.log(`‚úÖ Upload conclu√≠do: ${data.filename}`);
                // Fetch imediato ap√≥s confirma√ß√£o de upload
                setTimeout(() => fetchImages(), 500);
                break;

              case 'upload_error':
                console.error(`‚ùå Erro no upload: ${data.error}`);
                break;

              default:
                console.log('Mensagem WebSocket heatmap desconhecida:', data);
            }
          } catch (error) {
            console.error('Erro ao processar mensagem WebSocket do heatmap:', error);
          }
        };

        ws.onclose = () => {
          console.log('üîå Conex√£o WebSocket do heatmap fechada');
          setWsServerConnected(false);
          isConnected = false;

          // Tentar reconectar ap√≥s 5 segundos apenas se o componente ainda estiver montado
          if (!reconnectTimeout) {
            reconnectTimeout = setTimeout(() => {
              if (!isConnected) {
                console.log('üîÑ Tentando reconectar WebSocket do heatmap...');
                connectToWebSocket();
              }
            }, 5000);
          }
        };

        ws.onerror = (error) => {
          console.error('‚ùå Erro WebSocket do heatmap:', error);
          setWsServerConnected(false);
          isConnected = false;
        };

      } catch (error) {
        console.error('‚ùå Erro ao criar WebSocket do heatmap:', error);
        setWsServerConnected(false);
        isConnected = false;

        // Tentar reconectar ap√≥s 5 segundos
        if (!reconnectTimeout) {
          reconnectTimeout = setTimeout(() => {
            if (!isConnected) {
              connectToWebSocket();
            }
          }, 5000);
        }
      }
    };

    // Conectar inicialmente
    connectToWebSocket();

    return () => {
      isConnected = false;
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
      }
      if (ws) {
        ws.close();
      }
    };
  }, [heatmapWsUrl, fetchImages]);

  // Atualizar lista de imagens periodicamente - REDUZIDO para evitar spam
  useEffect(() => {
    // Buscar imagens na inicializa√ß√£o
    fetchImages();

    // Atualizar periodicamente a cada 30 segundos (reduzido de 15 para 30)
    const interval = setInterval(() => {
      // S√≥ atualizar se n√£o estiver em loading e se a janela estiver ativa
      if (!loading && document.hasFocus()) {
        console.log('üîÑ Update autom√°tico (30s)');
        fetchImages();
      }
    }, 30000); // 30 segundos

    return () => {
      clearInterval(interval);
    };
  }, [fetchImages, loading]);

  // Memoizar dados derivados
  const sessionIds = useMemo(() => groups ? Object.keys(groups) : [], [groups]);

  // Memoizar sess√µes ordenadas por status e atividade
  const sortedSessionIds = useMemo(() => {
    if (!groups || !sessionStats.sessionDetails) return sessionIds;

    return sessionIds.sort((a, b) => {
      const aDetail = sessionStats.sessionDetails[a];
      const bDetail = sessionStats.sessionDetails[b];
      const aDisconnected = disconnectedSessions.has(a);
      const bDisconnected = disconnectedSessions.has(b);
      const aOnline = aDetail?.isActive && !aDisconnected;
      const bOnline = bDetail?.isActive && !bDisconnected;

      // Primeiro: sess√µes online
      if (aOnline && !bOnline) return -1;
      if (!aOnline && bOnline) return 1;

      // Segundo: sess√µes desconectadas ficam por √∫ltimo
      if (aDisconnected && !bDisconnected) return 1;
      if (!aDisconnected && bDisconnected) return -1;

      // Terceiro: por √∫ltima atividade (mais recente primeiro)
      const aLastActivity = aDetail?.lastImageTime?.getTime() || 0;
      const bLastActivity = bDetail?.lastImageTime?.getTime() || 0;
      return bLastActivity - aLastActivity;
    });
  }, [sessionIds, sessionStats.sessionDetails, disconnectedSessions, groups]);

  return (
    <Box sx={{ display: 'flex', bgcolor: '#f5f5f5', minHeight: '100vh' }}>
      <CssBaseline />
      <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1, bgcolor: '#222' }}>
        <Toolbar>
          <Typography variant="h5" noWrap component="div">
            üìä Clarity Analytics Platform {wsServerConnected && 'üü¢'}
          </Typography>
        </Toolbar>
      </AppBar>

      <Sidebar
        sortedSessionIds={sessionIds}
        groups={groups}
        sessionStats={sessionStats}
        disconnectedSessions={disconnectedSessions}
      />

      <Box component="main" sx={{ flexGrow: 1, width: { sm: `calc(100% - ${drawerWidth}px)` } }}>
        <Toolbar />

        {loading ? (
          <Box display="flex" justifyContent="center" alignItems="center" minHeight="40vh">
            <CircularProgress />
          </Box>
        ) : (
          <Routes>
            <Route
              path="/"
              element={
                <OverviewPage
                  sessionStats={sessionStats}
                  lastUpdateTime={Date.now()} // Valor padr√£o
                  wsStats={{ totalMessages: 0, imagesReceived: 0, activeConnections: 0, serverStatus: wsServerConnected ? 'connected' : 'disconnected' }} // Valor padr√£o
                />
              }
            />
            <Route
              path="/sessions"
              element={
                <SessionsPage
                  sessionStats={sessionStats}
                  groups={groups}
                  selectedSession={null}
                  onSelectSession={handleSelectSession}
                  onCreateVideo={handleCreateVideo}
                  onDeleteSession={deleteSession}
                  disconnectedSessions={disconnectedSessions}
                  sessionStatus={{}} // Valor padr√£o vazio
                />
              }
            />
            <Route
              path="/online-session/:sessionId"
              element={
                <PlayerPage
                  groups={groups}
                  isPlaying={isPlaying}
                  currentImageIndex={currentImageIndex}
                  playbackSpeed={playbackSpeed}
                  onPlayPause={handlePlayPause}
                  onStop={handleStop}
                  onIndexChange={setCurrentImageIndex}
                  onSpeedChange={setPlaybackSpeed}
                  onDeleteSession={deleteSession}
                  sessionStats={sessionStats}
                  disconnectedSessions={disconnectedSessions}
                  sessionStatus={{}} // Valor padr√£o vazio
                />
              }
            />
          </Routes>
        )}
      </Box>
    </Box>
  );
}

// Componente principal com Router
function App() {
  return (
    <Router>
      <AppContent />
    </Router>
  );
}

export default App;
